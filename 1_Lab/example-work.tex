\documentclass[bachelor, och, pract4, times, hidelinks]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа

				%    pract2      - отчет по практике,  2 курс
				%    pract3      - отчет по практике,  3 курс
				%    pract4      - отчет по практике,  4 курс
%    nir      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
%\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[english,russian]{babel}
% выделение ссылок цветом. чтобы включить- true
\usepackage[colorlinks=false]{hyperref}

\graphicspath{{figures/}}

\lstset{%
	language=C,
	backgroundcolor=\color{gray!12},
	basicstyle=\ttfamily\small,
	keywordstyle=\color{blue},
	stringstyle=\color{blue},
	showstringspaces=false,
	captionpos=b,
	numbers=left,
	numberstyle=\footnotesize\color{gray},
	frame=TB,
	tabsize=2,
	morekeywords={procedure, then, begin, end}
}

\renewcommand{\rmdefault}{cmr} % курсив и полужирный включаются здесь.
\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{теории функций и стохастического анализа} 
%\chairr{кафедра теории функций и стохастического анализа} % для практик!!!!
\chairr{завод "Тантал"}% для практик!!!!

% Тема работы

\title{Правила оформления курсовых и дипломных работ}

% Курс
\course{4}

% Группа
\group{451}

\department{механико-математического факультета}

% Специальность/направление код - наименование
%\napravlenie{01.03.02 "--- Прикладная математика и информатика}
\napravlenie{38.03.05 "--- Бизнес-информатика}
%\napravlenie{09.04.03 "--- Прикладная информатика}

% Для СТУДЕНТКИ!!!. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Чайковского Петра Ильича}

% Заведующий кафедрой
\chtitle{д.\,ф.-м.\,н., доцент} % степень, звание
\chname{С.\,П.\,Сидоров}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
\saname{Н.\,Ю.\,Агафонова} % для 451 гр
%\saname{А.\,К.\,Смирнов} % для 412 гр

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
\patitle{ведущий программист}
\paname{Д.\,Э.\,Кнутов}

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{5}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
%\practtype{производственная(базовая)}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
%\duration{4}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{29.06.2019}
\practFinish{26.07.2019}

% Год выполнения отчета
\date{2019}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering

\tableofcontents



\section{Постановка задачи}

\par \textbf{Цель работы} — изучение основных свойств бинарных отношений и операций 
замыкания бинарных отношений. \\

\par \textbf{Порядок выполнения работы:}

\par \textbf{1}. Разобрать основные определения видов бинарных отношений и 
разработать алгоритмы классификации бинарных отношений.

\par \textbf{2}. Изучить свойства бинарных отношений и рассмотреть основные системы 
замыкания на множестве бинарных отношений.

\par \textbf{3}. Разработать алгоритмы построения основных замыканий бинарных 
отношений.

\newpage

\section{Теоретические сведения по рассмотренным темам с их обоснованием}

\par \textbf{Определение.} Подмножества декартова произведения $ A \times B $ 
множеств $ A $ и $ B $ называется \textit{бинарными отношениями} между элементами
множеств $ A, B $ и обозначаются строчными греческими буквами: $ \rho, \sigma, 
\dots, \rho_1, \rho_2, \dots .$ \\

\par \textbf{Определение.} Бинарное отношение $ \rho \subset A \times A $ 
называется: \\
1. \textit{рефлексивным}, если $ (a,\,a) \in \rho $ для всякого $ a \in A $; \\
2. \textit{симметричным}, если $ (a,\,b) \in \rho \implies (b,\,a) \in \rho $ для всяких $ a, b \in A $; \\
3. \textit{антисимметричным}, если $ (a,\,b) \in \rho $ и $ (b,\,a) \in \rho 
\implies a = b $ для всяких $ a, b \in A $; \\
4. \textit{транзитивным}, если $ (a,\,b) \in \rho $ и $ (b,\,c) \in \rho \implies (a,\,c) \in \rho $ для всяких
$ a, b, c \in A $. \\

Символом $ \Delta_A $ обозначается тождественное отношение на множестве $ A $, которое определяется по
формуле: $$ \Delta_A = \{\,(a,\,a)\,|\, a \in A\,\}. $$

Тогда бинарное отношение $ \rho \subset A \times A $ является: \\
1. \textit{рефлексивным}, если $ \Delta_A \subset \rho $; \\
2. \textit{симметричным}, если $ \rho^{-1} \subset \rho $; \\ 
3. \textit{антисимметричным}, если $ \rho \cap \rho^{-1} \subset \Delta_A $; \\
4. \textit{транзитивным}, если $ \rho\rho \subset \rho $. \\

\par \textbf{Определение.} Бинарное отношение $ \rho $ на множестве $ A $ называется: \\
1. \textit{отношением эквивалентности (эквивалентностью)}, если оно рефлексивно, симметрично и транзитивно. \\
2. \textit{отношением порядка (порядком)}, если оно рефлексивно, антисимметрично и транзитивно. \\
3. \textit{отношением квазипорядка (квазипорядком)}, если оно рефлексивно и транзитивно.

\newpage

\par \textbf{Определение.} Множество $ Z $ подмножеств множества $ A $ называется \textit{системой замыканий},
если оно замкнуто относительно пересечений, т.е. выполняется: $$ \bigcap B \in Z \quad \forall B \subset Z. $$
В частности, для $ \varnothing \subset Z $ выполняется $ \cap \varnothing = A \in Z $. \\

\par \textbf{Лемма 1. О системах замыканий бинарных отношений.} На множестве $ P(A^2) $ всех бинарных 
отношений между элементами множества $ A $ следующие множества являются системами замыканий: 
\par 1. $ Z_r $ - множество всех рефлексивных бинарных отношений между элементами множества $ A $. 
\par 2. $ Z_s $ - множество всех симметричных бинарных отношений между элементами множества $ A $.
\par 3. $ Z_t $ - множество всех транзитивных бинарных отношений между элементами множества $ A $.
\par 4. $ Z_{eq} = Eq(A) $ - множество всех отношений эквивалентности на множестве $ A $.
\par Множество $ Z_{as} $ всех антисимметричных бинарных отношений между элементами множества $ A $ не 
является системой замыканий. \\

\par \textbf{Определение.} \textit{Оператором замыкания} на множестве $ A $ называется отображение $ f $
множества всех подмножеств $ P(A) $ в себя, удовлетворяющее условиям: 
\par 1) $ X \subset Y \implies f(X) \subset f(Y) $;
\par 2) $ X \subset f(X) $;
\par 3) $ (f \circ f)(X) = f(X) $ \\
для всех $ X, Y \in P(A). $ Для подмножества $ X \subset A $ значение $ f(X) $ называется \textit{замыканием}
подмножества $ X $. \\

\newpage

\par \textbf{Лемма 2. О замыканиях бинарных отношений.} На множестве $ P(A^2) $ всех бинарных отношений 
между элементами множества $ A $ следующие отображения являются операторами замыканий:
\par 1) $ f_r(\rho) = \rho \cup \Delta_A $ - наименьшее рефлексивное бинарное отношение, содержащее 
отношение $ \rho \subset A^2 $,

\par 2) $ f_s(\rho) = \rho \cup \rho^{-1} $ - наименьшее симметричное бинарное отношение, содержащее 
отношение $ \rho \subset A^2 $,

\par 3) $ f_t(\rho) = \bigcup\limits_{n=1}^{\infty}\rho^n $ - наименьшее транзитивное бинарное отношение, 
содержащее отношение $ \rho \subset A^2 $,

\par 4) $ f_{eq}(\rho) $ = $ (f_t \circ f_s \circ f_r)(\rho) $ - наименьшее отношение эквивалентности,
содержащее отношение $ \rho \subset A^2 $.

\section{Результаты работы}
\subsection{Алгоритм определения свойства рефлексивности.}

\textbf{Описание алгоритма определения свойства рефлексивности.} \\
\textbf{Вход:} список смежности бинарного отношения $ \rho $. \\
\textbf{Выход:} строка <<Бинарное отношение является/не является рефлексивным.>> и bool значение \textbf{true}
или \textbf{false}. \\
\textbf{Метод:} для каждого элемента $ a $, находящегося в бинарном отношении $ \rho $ (с некоторыми 
элементами $ b_i $), просматривается его список смежности. В этом списке смежности ищется сам элемент $ a $.
Алгоритм прекрщает свою работу, если был найден элемент $ a $, список смежности которого не содержит $ a $, 
или, если для всякого элемента $ a $ его список смежности содержит $ a $. \\

\par \textbf{Псевдокод алгоритма определения свойства рефлексивности.}

\begin{lstlisting}[caption=Псевдокод алгоритма., mathescape]
isReflexive(binaryRelation)
{
	for element in binaryRelation
	{
		flag = false

		for subelement in element:
			if (subelement == element):			
				flag = true
			
		if (!flag)
			return false
	}

	return true
}
\end{lstlisting}

\newpage

\par \textbf{Код программы, реализующей алгоритм определения свойства рефлексивности.}

\begin{lstlisting}[caption=Код программы., mathescape]
bool isReflexive(map<int, set<int>> binaryRelation)
{
	bool isReflexive = false;
	set<int> ::iterator it;
	int i;
	
	for (auto element : binaryRelation)
	{
		isReflexive = false;
		it = element.second.begin();

		for (; it != element.second.end(); ++it)
			if (element.first == *it)
			{
				isReflexive = !isReflexive;
				break;
			}
	
		if (!isReflexive)
			break;
	}
	
	cout << "\n" << 
		(isReflexive ? "\nBINARY RELATION IS REFLEXIVE.\n" : 
					   			 "\nBINARY RELATION IS NOT REFLEXIVE.\n");
	return isReflexive;
}
\end{lstlisting}

\newpage

\par \textbf{Результат тестирования программы определения свойства рефлексивности.}

\par Для демонстрации работы программы рассмотрим два произвольных бинарных отношения $ \rho $ и $ \delta $, 
для одного из которых свойство рефлексивности выполняется, а для другого нет.
\par Сгенерируем 8 пар элементов, соответствующих бинарному отношению $ \rho $. Получаем следующие пары: 

\begin{figure}[h]
	\center{\includegraphics{/reflexiveCheck/is_reflexive_check.png}}
	\caption{Пары элементов, находящихся в нерефлексивном бинарном отношении.}
\end{figure}

\par Как видно, данное отношение не является рефлексивным. Посмотрим на выход программы:

\begin{figure}[h]
	\center{\includegraphics{/reflexiveCheck/is_reflexive_check_failed.png}}
	\caption{Проверка на рефлексивность не пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение не является рефлексивным. Теперь рассмотрим 
бинарное отношение $ \delta $, для которого свойство рефлексивности выполняется. Рассмотрим 8 следующих пар: 

\begin{figure}[h]
	\center{\includegraphics{/reflexiveCheck/reflexive_binary_relation.png}}
	\caption{Пары элементов, находящихся в рефлексивном бинарном отношении.}
\end{figure}

\newpage

\par Как видно, отношение является рефлексивным. Посмотрим на выход программы: 

\begin{figure}[h]
	\center{\includegraphics{/reflexiveCheck/is_reflexive_check_success.png}}
	\caption{Проверка на рефлексивность пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение является рефлексивным. \\

\par \textbf{Оценка временной сложности алгоритма определения свойства рефлексивности.} 
\par Будем считать, что алгоритм отрабатывает полностью, а не встречает элемент, который гарантирует 
невыполнение свойства рефлексивности (в таком случае программа преждевременно завершает своё выполнение). 
Посчитаем число элементарных операций, выполняемых алгоритмом. Пусть число уникальных элементов, входящих в 
бинарное отношение с другими элементами $ b_i $, равно $ n $. Определим число $ n_i $ как количество элементов 
в списке смежности $i$-го по счёту элемента. Тогда \textit{верхняя граница} числа элементарных операций, 
выполняемых алгоритмом, будет равна: $$ n_1 + n_2 + \dots + n_n = \sum\limits_{i = 1}^{n}\,n_i \leq n^2 \implies 
T(\textit{isReflexive,\,n}) = O(n^2). $$

\newpage

\subsection{Алгоритм определения свойства симметричности.}

\textbf{Описание алгоритма определения свойства симметричности.}
\textbf{Вход:} список смежности бинарного отношения $ \rho $. \\
\textbf{Выход:} строка <<Бинарное отношение является/не является симметричным.>> и bool значение \textbf{true}
или \textbf{false}. \\
\textbf{Метод:} для каждого элемента $ a $, находящегося в бинарном отношении $ \rho $ (с некоторыми 
элементами $ b_i $), просматривается его список смежности. Для каждого элемента $ b_i $ из списка смежности 
элемента $ a $ просматривается его список смежности, и в нём ищется элемент $ a $. Алгоритм прекращает свою 
работу, если был найден элемент $ b_i $ из списка смежности элемента $ a $, список смежности которого не 
содержит элемента $ a $, или, если для всякого элемента $ a $ списки смежностей элементов $ b_i $ 
содержат $ a $. \\

\par \textbf{Псевдокод алгоритма определения свойства симметричности.}

\begin{lstlisting}[caption=Псевдокод алгоритма., mathescape]
isSymmetric(binaryRelation)
{
	for element in binaryRelation			
		for subelement in element
		{
			flag = false

			if element in binaryRelation[subelement]
				flag = true

			if (!flag)
				return false
		}

	return true
}
\end{lstlisting}

\newpage

\par \textbf{Код программы, реализующей алгоритм определения свойства симметричности.}

\begin{lstlisting}[caption=Код программы., mathescape]
bool isSymmetric(map<int, set<int>> binaryRelation)
{
	bool isSymmetric = false;
	set<int> ::iterator it, itHelper;

	for (auto element : binaryRelation)
	{
		it = element.second.begin();

		for (; it != element.second.end(); ++it)
		{
			isSymmetric = false;

			if (!binaryRelation[*it].empty())
			{
				itHelper = binaryRelation[*it].begin();

				for (; itHelper != binaryRelation[*it].end(); ++itHelper)
					if (element.first == *itHelper)
					{
						isSymmetric = !isSymmetric;
						break;
					}
			}
            
			if (!isSymmetric)
			{
				cout << "\nBINARY RELATION IS NOT SYMMETRIC.\n";
				return false;
			}
		}
	}

	cout << "\nBINARY RELATION IS SYMMETRIC.\n";
	return true;
}
\end{lstlisting}

\newpage

\par \textbf{Результат тестирования программы определения свойства симметричности.}

\par Для демонстрации работы программы рассмотрим два произвольных бинарных отношения $ \rho $ и $ \delta $, 
для одгого из которых свойство симметричности выполняется, а для другого нет.
\par Сгенерируем 8 пар элементов, соответствующих бинарному отношению $ \rho $. Получаем следующие пары: 

\begin{figure}[h]
	\center{\includegraphics{/symmetricCheck/is_symmetric_check.png}}
	\caption{Пары элементов, находящихся в несимметричном бинарном отношении.}
\end{figure}

\par Как видно, данное отношение не является симметричным. Посмотрим на выход программы:

\begin{figure}[h]
	\center{\includegraphics{/symmetricCheck/is_symmetric_check_failed.png}}
	\caption{Проверка на симметричность не пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение не является симметричным. Теперь рассмотрим 
бинарное отношение $ \delta $, для которого свойство симметричности выполняется. Рассмотрим 8 следующих пар
(число сгенерированных пар элементов может быть меньше, поскольку некоторые пары при генерации могли совпасть): 

\begin{figure}[h]
	\center{\includegraphics{/symmetricCheck/symmetric_binary_relation.png}}
	\caption{Пары элементов, находящихся в симметричном бинарном отношении.}
\end{figure}

\newpage

\par Как видно, отношение является симметричным. Посмотрим на выход программы: 

\begin{figure}[h]
	\center{\includegraphics{/symmetricCheck/is_symmetric_check_success.png}}
	\caption{Проверка на симметричность пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение является симметричным. \\

\par \textbf{Оценка временной сложности алгоритма определения свойства симметричности.} 
\par Будем считать, что алгоритм отрабатывает полностью, а не встречает элемент, который гарантирует 
невыполнение свойства симметричности (в таком случае программа преждевременно завершает своё выполнение). 
Посчитаем число элементарных операций, выполняемых алгоритмом. Пусть число уникальных элементов, входящих в 
бинарное отношение с другими элементами $ b_i $, равно $ n $. Определим число $ n_i $ как количество элементов 
в списке смежности $i$-го по счёту элемента, а $ n_{ij} $ как $j$-ый по счёту элемент в таком списке смежности.
Тогда \textit{верхняя граница} числа элементарных операций, выполняемых алгоритмом, будет равна: 
$$ n_{n_{11}} + \dots + n_{n_{1n}} + n_{n_{21}} + \dots + n_{n_{nn}} \leq 
n\sum\limits_{i = 1}^{n}\, n_i \leq n^3 \implies T(\textit{isSymmetric},\,n) = O(n^3). $$

\newpage

\subsection{Алгоритм определения свойства антисимметричности.}

\textbf{Описание алгоритма определения свойства антисимметричности.}
\textbf{Вход:} список смежности бинарного отношения $ \rho $. \\
\textbf{Выход:} строка <<Бинарное отношение является/не является антисимметричным.>> и bool значение 
\textbf{true} или \textbf{false}. \\
\textbf{Метод:} для каждого элемента $ a $, находящегося в бинарном отношении $ \rho $ (с некоторыми 
элементами $ b_i $), просматривается его список смежности. Для каждого элемента $ b_i $ из списка смежности 
элемента $ a $ просматривается его список смежности. В этом списке смежности не должно содержаться элемента 
$ a $, за исключением ситуации, когда $ a $ и $ b_i $ - один и тот же элемент, и переход из $ a $ в 
$ b_i $ - петля. \\

\par \textbf{Псевдокод алгоритма определения свойства антисимметричности.}

\begin{lstlisting}[caption=Псевдокод алгоритма., mathescape]
isAntisymmetric(binaryRelation)
{	
	for element in binaryRelation:	
		for subelement in element
		{
			isAntisymmetric = true

			if subelement is not element
			{
				for elt in binaryRelation[subelement]
					if (elt == element)
						isAntisymmetric = false
			}
	
			if (!isAntisymmetric)			
				return false
		}

	return true
}
\end{lstlisting}

\newpage

\par \textbf{Код программы, реализующей алгоритм определения свойства антисимметричности.}

\begin{lstlisting}[caption=Код программы., mathescape]
bool isAntisymmetric(map<int, set<int>> binaryRelation)
{
	bool isAntisymmetric = false;
	set<int> ::iterator it, itHelper;

	for (auto element : binaryRelation)
	{
		it = element.second.begin();

		for (; it != element.second.end(); ++it)
		{
			isAntisymmetric = true;

			if (!binaryRelation[*it].empty() && *it != element.first)
			{
				itHelper = binaryRelation[*it].begin();

				for (; itHelper != binaryRelation[*it].end(); ++itHelper)
					if (*itHelper == element.first)
						isAntisymmetric = false;
			}

			if (!isAntisymmetric)
			{
				cout << "\nBINARY RELATION IS NOT ANTISYMMETRIC.\n";
				return false;
			}            
		}
	}

	cout << "\nBINARY RELATION IS ANTISYMMETRIC.\n";
	return true;
}
\end{lstlisting}

\newpage

\par \textbf{Результат тестирования программы определения свойства антисимметричности.}

\par Для демонстрации работы программы рассмотрим два произвольных бинарных отношения $ \rho $ и $ \delta $, 
для одгого из которых свойство антисимметричности выполняется, а для другого нет.
\par Сгенерируем 8 пар элементов (число сгенерированных пар элементов может быть меньше, поскольку некоторые
пары при генерации могли совпасть), соответствующих бинарному отношению $ \rho $. Получаем следующие пары: 

\begin{figure}[h]
	\center{\includegraphics{/antisymmetricCheck/is_antisymmetric_check.png}}
	\caption{Пары элементов, находящихся в неантисимметричном бинарном отношении.}
\end{figure}

\par Как видно, данное отношение не является антисимметричным. Посмотрим на выход программы:

\begin{figure}[h]
	\center{\includegraphics{/antisymmetricCheck/is_antisymmetric_check_failed.png}}
	\caption{Проверка на антисимметричность не пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение не является антисимметричным. Теперь рассмотрим 
бинарное отношение $ \delta $, для которого свойство антисимметричности выполняется. Рассмотрим 8 следующих пар: 

\begin{figure}[h]
	\center{\includegraphics{/antisymmetricCheck/antisymmetric_binary_relation.png}}
	\caption{Пары элементов, находящихся в симметричном бинарном отношении.}
\end{figure}

\newpage

\par Как видно, отношение является антисимметричным. Посмотрим на выход программы: 

\begin{figure}[h]
	\center{\includegraphics{/antisymmetricCheck/is_antisymmetric_check_success.png}}
	\caption{Проверка на симметричность пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение является антисимметричным. \\

\par \textbf{Оценка временной сложности алгоритма определения свойства антисимметричности.} 
\par Будем считать, что алгоритм отрабатывает полностью, а не встречает элемент, который гарантирует 
невыполнение свойства антисимметричности (в таком случае программа преждевременно завершает своё выполнение). 
Поскольку принцип работы этого алгоритма аналогичен тому, что используется в алгоритм определения свойства 
симметричности, то для этого алгоритма выполняется оценка сложности, полученная ранее: $$ n_{n_{11}} + 
\dots + n_{n_{1n}} + n_{n_{21}} + \dots + n_{n_{nn}} \leq n\sum\limits_{i = 1}^{n}\, n_i \leq n^3 
\implies T(\textit{isAntisymmetric}, n) = O(n^3). $$

\newpage

\subsection{Алгоритм определения свойства транзитивности.}

\textbf{Описание алгоритма определения свойства транзитивности.}
\textbf{Вход:} список смежности бинарного отношения $ \rho $. \\
\textbf{Выход:} строка <<Бинарное отношение является/не является транзитивным.>> и bool значение \textbf{true}
или \textbf{false}. \\
\textbf{Метод:} для каждого элемента $ a $, находящегося в бинарном отношении $ \rho $ (с некоторыми 
элементами $ b_i $), просматривается его список смежности. Для каждого элемента $ b_i $ из списка смежности 
элемента $ a $ просматривается его список смежности. Для удовлетворения условия транзитивности каждый элемент 
из списка смежности $ b_i $ должен содержаться в списке смежности элемента $ a $. Алгоритм завершает свою 
работу, если находится такой элемент, что это условие для него не выполняется, или после проверки и выполнения
этого условия для всякого элемента $ a $. \\

\par \textbf{Псевдокод алгоритма определения свойства транзитивности.}

\begin{lstlisting}[caption=Псевдокод алгоритма., mathescape]
isTransitive(binaryRelation)
{	
	for element in binaryRelation:	
		for subelement in element:		
			for elt in binaryRelation[subelement]
			{
				isTransitive = false

				for eltSup in element:
					if (elt == eltSup)
						isTransitive = true

				if (!isTransitive)				
					return false				
			}	

	return true
}
\end{lstlisting}

\newpage

\par \textbf{Код программы, реализующей алгоритм определения свойства транзитивности.}

\begin{lstlisting}[caption=Код программы., mathescape]
bool isTransitive(map<int, set<int>> binaryRelation)
{
	bool isTransitive = false;
	set<int> ::iterator it, itHelper, itSup;
	
	for (auto element : binaryRelation)
	{
		it = element.second.begin();
	
		for (; it != element.second.end(); ++it)
		{
			if (!binaryRelation[*it].empty())
			{
				itHelper = binaryRelation[*it].begin();
				
				for (; itHelper != binaryRelation[*it].end(); ++itHelper)
				{
					itSup = element.second.begin();
					isTransitive = false;

					for (; itSup != element.second.end(); ++itSup)
						if (*itHelper == *itSup)
							isTransitive = !isTransitive;

					if (!isTransitive)
					{
						cout << "\nBINARY RELATION IS NOT TRANSITIVE.\n";
						return false;
					}
				}
			}
		}
	}	
	cout << "\nBINARY RELATION IS TRANSITIVE.\n";
	return true;
}
\end{lstlisting}

\newpage

\par \textbf{Результат тестирования программы определения свойства транзитивности.}

\par Для демонстрации работы программы рассмотрим два произвольных бинарных отношения $ \rho $ и $ \delta $, 
для одгого из которых свойство транзитивности выполняется, а для другого нет.
\par Сгенерируем 8 пар элементов, соответствующих бинарному отношению $ \rho $. Получаем следующие пары: 

\begin{figure}[h]
	\center{\includegraphics{/transitiveCheck/is_transitive_check.png}}
	\caption{Пары элементов, находящихся в нетранзитивном бинарном отношении.}
\end{figure}

\par Как видно, данное отношение не является транзитивным. Посмотрим на выход программы:

\begin{figure}[h]
	\center{\includegraphics{/transitiveCheck/is_transitive_check_failed.png}}
	\caption{Проверка на транзитивность не пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение не является транзитивным. Теперь рассмотрим 
бинарное отношение $ \delta $, для которого свойство транзитивности выполняется. Перейдём на ручной ввод и 
введём 8 пар элементов: 

\begin{figure}[h]
	\center{\includegraphics{/transitiveCheck/transitive_binary_relation.png}}
	\caption{Пары элементов, находящихся в транзитивном бинарном отношении.}
\end{figure}

\newpage

\par Как видно, отношение является транзитивным. Посмотрим на выход программы: 

\begin{figure}[h]
	\center{\includegraphics{/transitiveCheck/is_transitive_check_success.png}}
	\caption{Проверка на транзитивность пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение является транзитивным. \\

\par \textbf{Оценка временной сложности алгоритма определения свойства транзитивности.} 
\par Будем считать, что алгоритм отрабатывает полностью, а не встречает элемент, который гарантирует 
невыполнение свойства транзитивности (в таком случае программа преждевременно завершает своё выполнение). 
Определим $ n $ как число уникальных элементов, встречающихся в бинарном отношении, $ n_i $ как число элементов
в списке смежности элемента с $i$-ым номером, а $ n_{ij} $ как $j$-ый элемент в таком списке смежности. Тогда
число элементарных операций для одного элемента (например, первого) может быть вычислено как: 
$$ n_1n_{n_{11}} + n_1n_{n_{12}} + \dots + n_1n_{n_{1n}} = n_1 \sum\limits_{i = 1}^{n} n_{n_{1i}}. $$ 
А для $ n $ элементов: $$ n_1 \sum\limits_{i = 1}^{n} n_{n_{1i}} + n_2 \sum\limits_{i = 1}^{n} n_{n_{2i}} + 
\dots + n_n \sum\limits_{i = 1}^{n} n_{n_{ni}} = \sum\limits_{j = 1}^{n} (n_j \sum\limits_{i=1}^{n} n_{n_{ji}}),$$
$$ \sum\limits_{i=1}^{n} n_{n_{ji}} \leq \sum_{i=1}^{n} n_i \leq n^2 \implies 
\sum\limits_{j = 1}^{n} (n_j \sum\limits_{i=1}^{n} n_{n_{ji}}) \leq n^2 \sum\limits_{i = 1}^{n} n_i \leq n^4.$$
Получаем, что $ T(\textit{isTransitive},\,n) = O(n^4). $
\newpage

\subsection{Алгоритм классификации бинарных отношений.}

Отдельно рассмотрим три функции, определяющих класс бинарного отношения, а именно: отношение эквивалентности,
отношение порядка или отношение квазипорядка. Тогда алгоритм, содержащий в себе эти три функции, может 
выглядеть следующим образом: \\
\textbf{Вход:} список смежности бинарного отношения $ \rho $. \\
\textbf{Выход:} строки <<Бинарное отношение является/не является отношением эквивалентности.>>, 
<<Бинарное отношение является/не является отношением порядка.>>, <<Бинарное отношение является/не 
является отношением квазипорядка.>> \\
\textbf{Метод:} последовательно запускаем функции проверки принадлежности бинарного отношение к соответствующему
классу. \\

\par \textbf{Код программы, реализующей алгоритм классификации бинарных отношений.}

\begin{lstlisting}[caption={Набор функций, осуществляющий классификацию бинарных отношений.}, mathescape]
void isEquivalence(map<int, set<int>> binaryRelation)
{
	if (isReflexive(binaryRelation) && 
			isSymmetric(binaryRelation) && 
			isTransitive(binaryRelation))
		cout << "\nBINARY RELATION IS AN EQUIVALENT RELATION.\n";
	else
		cout << "\nBINARY RELATION IS NOT AN EQUIVALENT RELATION.\n";
}
	
void isOrder(map<int, set<int>> binaryRelation)
{
	if (isReflexive(binaryRelation) && 
			isAntisymmetric(binaryRelation) && 
			isTransitive(binaryRelation))
		cout << "\nBINARY RELATION IS AN ORDER RELATION.\n";
	else
		cout << "\nBINARY RELATION IS NOT AN ORDER RELATION.\n";
}
	
void isQuasi(map<int, set<int>> binaryRelation)
{
	if (isReflexive(binaryRelation) && 
			isTransitive(binaryRelation))
		cout << "\nBINARY RELATION IS A QUASI-ORDER RELATION.\n";
	else
		cout << "\nBINARY RELATION IS NOT A QUASI-ORDER RELATION.\n";
}
\end{lstlisting}

\par \textbf{Результат тестирования программы классификации бинарных отношений.} 
\par Для демонстрации работы программы рассмотрим шесть произвольных бинарных отношений $ \rho_i, \, i = 
\overline{1, 6} $. В каждой паре одно отношение будет принадлежать какому-нибудь классу, а другое - нет. Начнём
с рассмотрения отношения эквивалентности. 

\par Сгенерируем 8 пар элементов, соответствующих бинарному отношению $ \rho_1 $. Получаем следующие пары: 

\begin{figure}[h]
	\center{\includegraphics{classificationCheck/equivalenceCheck/is_equivalence_check.png}}
	\caption{Пары элементов, находящихся в неэквивалентном бинарном отношении.}
\end{figure}

\par Как видно, данное отношение не является эквивалентностью. Посмотрим на выход программы:

\begin{figure}[h]
	\center{\includegraphics{classificationCheck/equivalenceCheck/is_equivalence_check_failed.png}}
	\caption{Проверка на эквивалентность не пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение не является эквивалентностью. Также программа 
сообщила, почему данное отношение не является эквивалентностью - оно нерефлексивно. Теперь рассмотрим 
бинарное отношение $ \rho_2 $, которое является эквивалентностью. Перейдём на ручной ввод и
введём 9 следующих пар: 

\begin{figure}[h]
	\center{\includegraphics{classificationCheck/equivalenceCheck/equivalent_binary_relation.png}}
	\caption{Пары элементов, находящихся в эквивалентном бинарном отношении.}
\end{figure}

\par Как видно, отношение является эквивалентностью. Посмотрим на выход программы: 

\begin{figure}[h]
	\center{\includegraphics{classificationCheck/equivalenceCheck/is_equivalence_check_success.png}}
	\caption{Проверка на эквивалентность пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение является эквивалентностью, поскольку каждое из
необходимых свойств выполняется. \\

\newpage

\par Теперь перейдём к рассмотрению отношения порядка.

\par Сгенерируем 8 пар элементов, соответствующих бинарному отношению $ \rho_3 $. Получаем следующие пары: 

\begin{figure}[h]
	\center{\includegraphics{classificationCheck/orderCheck/is_order_check.png}}
	\caption{Пары элементов, не находящихся в бинарном отношении порядка.}
\end{figure}

\par Как видно, данное отношение не является порядком. Посмотрим на выход программы:

\begin{figure}[h]
	\center{\includegraphics{classificationCheck/orderCheck/is_order_check_failed.png}}
	\caption{Проверка на упорядоченность не пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение не является отношением порядка. Также программа 
сообщила, почему данное отношение не является отношением порядка - оно нерефлексивно. Теперь рассмотрим 
бинарное отношение $ \rho_4 $, которое является отношением порядка. Перейдём на ручной ввод и
введём 6 следующих пар: 

\begin{figure}[h]
	\center{\includegraphics{classificationCheck/orderCheck/order_binary_relation.png}}
	\caption{Пары элементов, находящихся в упорядоченном бинарном отношении.}
\end{figure}

\newpage

\par Как видно, отношение является отношением порядка. Посмотрим на выход программы: 

\begin{figure}[h!]
	\center{\includegraphics{classificationCheck/orderCheck/is_order_check_success.png}}
	\caption{Проверка на упорядоченность пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение является порядком, поскольку каждое из
необходимых свойств выполняется. \\

\par Теперь перейдём к рассмотрению отношения квазипорядка.

\par Сгенерируем 8 пар элементов, соответствующих бинарному отношению $ \rho_5 $. Получаем следующие пары: 

\begin{figure}[h]
	\center{\includegraphics{classificationCheck/quasiCheck/is_quasi_check.png}}
	\caption{Пары элементов, не находящихся в бинарном отношении квазипорядка.}
\end{figure}

\par Как видно, данное отношение не является квазипорядком. Посмотрим на выход программы:

\begin{figure}[h!]
	\center{\includegraphics[scale=0.9]{classificationCheck/quasiCheck/is_quasi_check_failed.png}}
	\caption{Проверка на упорядоченность не пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение не является отношением квазипорядка. Также программа 
сообщила, почему данное отношение не является отношением квазипорядка - оно нерефлексивно. Теперь рассмотрим 
бинарное отношение $ \rho_6 $, которое является отношением квазипорядка. Перейдём на ручной ввод и
введём 7 следующих пар: 

\begin{figure}[h]
	\center{\includegraphics{classificationCheck/quasiCheck/quasi_binary_relation.png}}
	\caption{Пары элементов, находящихся в квазиупорядоченном бинарном отношении.}
\end{figure}

\par Как видно, отношение является отношением квазипорядка. Посмотрим на выход программы: 

\begin{figure}[h!]
	\center{\includegraphics{classificationCheck/quasiCheck/is_quasi_check_success.png}}
	\caption{Проверка на квазиупорядоченность пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение является квазипорядком, поскольку каждое из
необходимых свойств выполняется. \\

\par \textbf{Оценка временной сложности алгоритма классификации бинарных отношений.} 
\par Поскольку каждый из алгоритмов классификации использует уже готовые функции, то для них мы сразу можем дать 
оценку временной сложности: 
\par Для каждого алгоритма классификации бинарного отношения: \\
$T(\textit{isEquivalence},\,n) = T(\textit{isOrder},\,n) = T(\textit{isQuasi},\,n) = O(n^4). $

\newpage

\subsection{Алгоритм построения рефлексивного замыкания бинарного отношения.}

\textbf{Описание алгоритма построения рефлексивного замыкания бинарного отношения.}
\textbf{Вход:} список смежности бинарного отношения $ \rho $. \\
\textbf{Выход:} замкнутое относительно свойства рефлексивности бинарное отношение $ \rho $. \\
\textbf{Метод:} для каждого элемента $ a $, находящегося в бинарном отношении $ \rho $ (с некоторыми 
элементами $ b_i $), в его список смежности добавляется элемент $ a $. \\

\par \textbf{Псевдокод алгоритма построения рефлексивного замыкания бинарного отношения.}

\begin{lstlisting}[caption=Псевдокод алгоритма., mathescape]
reflexiveClosure(binaryRelation)
{
	for element in binaryRelation
	{
		placeholder = element
		binaryRelation[element].insert(element);
	}
	
	return binaryRelation;
}
\end{lstlisting}

\newpage

\par \textbf{Код программы, реализующей алгоритм построения рефлексивного замыкания бинарного отношения.}

\begin{lstlisting}[caption=Код программы., mathescape]
map<int, set<int>> 
		reflexiveClosure(map<int, set<int>> binaryRelation)
{
	int i, placeholder;
	set<int> ::iterator it;

	for (auto element : binaryRelation)
	{
		placeholder = element.first;

		binaryRelation[element.first].insert(element.first);
	}

	return binaryRelation;
}
\end{lstlisting}

\par \textbf{Результат тестирования программы рефлексивного замыкания бинарного отношения.}

\par Для демонстрации работы программы рассмотрим произвольное отношение $ \delta $.
\par Сгенерируем 3 пары элементов, соответствующих бинарному отношению $ \delta $. Получаем следующие пары: 

\begin{figure}[h]
	\center{\includegraphics{/closures/reflexiveClosure/binary_relation.png}}
	\caption{Бинарное отношение, не обладающее свойством рефлексивности.}
\end{figure}

\newpage

\par Как видно, данное отношение не является рефлексивным. Построим рефлексивное замыкание этого бинарного 
отношения:

\begin{figure}[h]
	\center{\includegraphics{/closures/reflexiveClosure/closed_binary_relation.png}}
	\caption{Бинарное отношение после рефлексивного замыкания.}
\end{figure}

\par Как можно видеть, получившееся бинарное отношение является замкнутым относительно свойства рефлексивности, 
что подтверждает выход программы \textit{isReflexive.} \\

\par \textbf{Оценка временной сложности алгоритма рефлексивного замыкания бинарного отношения.} 
\par Определим $ n $ как число уникальных элементов, встречающихся в бинарном отношении. Для каждого такого 
элемента в его список смежности должен быть добавлен он сам. В зависимости от реализации контейнера, являющегося
списком смежности, сложность добавления элемента будет отличаться. Мы используем структуру set, 
асимптотическая сложность добавления элемента в него равна $ O(\log n) $. Тогда 
$ T(\textit{reflexiveClosure},\, n) = O(n\log n) $.

\newpage

\subsection{Алгоритм построения симметричного замыкания бинарного отношения.}

\textbf{Описание алгоритма построения симметричного замыкания бинарного отношения.} \\
\textbf{Вход:} список смежности бинарного отношения $ \rho $. \\
\textbf{Выход:} замкнутое относительно свойства симметричности бинарное отношение $ \rho $. \\
\textbf{Метод:} для каждого элемента $ a $, находящегося в бинарном отношении $ \rho $ с некоторыми 
элементами $ b_i $, в список смежности каждого такого элемента $ b_i $ добавляется элемент $ a $. \\

\par \textbf{Псевдокод алгоритма построения симметричного замыкания бинарного отношения.}

\begin{lstlisting}[caption=Псевдокод алгоритма., mathescape]
symmetricClosure(binaryRelation)
{
	for element in binaryRelation:
		for subelement in element:
			binaryRelation[subelement].insert(element)
	
	return binaryRelation;
}
\end{lstlisting}

\newpage

\par \textbf{Код программы, реализующей алгоритм построения симметричного замыкания бинарного отношения.}

\begin{lstlisting}[caption=Код программы., mathescape]
map<int, set<int>> 
		symmetricClosure(map<int, set<int>> binaryRelation)
{
	set<int> ::iterator it;
	for (auto element : binaryRelation)
	{
		it = element.second.begin();
		for (; it != element.second.end(); ++it)
			binaryRelation[*it].insert(element.first);
	}
	return binaryRelation;
}
\end{lstlisting}

\par \textbf{Результат тестирования программы симметричного замыкания бинарного отношения.}

\par Для демонстрации работы программы рассмотрим произвольное отношение $ \delta $.
\par Сгенерируем 3 пары элементов, соответствующих бинарному отношению $ \delta $. Получаем следующие пары: 

\begin{figure}[h]
	\center{\includegraphics{/closures/symmetricClosure/binary_relation.png}}
	\caption{Бинарное отношение, не обладающее свойством симметричности.}
\end{figure}

\par Как видно, данное отношение не является симметричным. Построим симметричное замыкание этого бинарного 
отношения:

\newpage

\begin{figure}[h]
	\center{\includegraphics{/closures/symmetricClosure/closed_binary_relation.png}}
	\caption{Бинарное отношение после симметричного замыкания.}
\end{figure}

\par Как можно видеть, получившееся бинарное отношение является замкнутым относительно свойства симметричности, 
что подтверждает выход программы \textit{isSymmetric.} \\

\par \textbf{Оценка временной сложности алгоритма симметричного замыкания бинарного отношения.} 
\par Определим $ n $ как число уникальных элементов, встречающихся в бинарном отношении, $ n_i $ как число
элементов в списке смежности $i$-го элемента, а $ n_{ij} $ как $j$-ый элемент в таком списке смежности. Для 
каждого элемента $ n_{ij} $ в список смежности $ n_{n_{ij}} $ должен быть добавлен $i$-ый элемент.
Тогда число элементарных операций для одного элемента (например, первого), составляет: $ n_1 $, а временная 
сложность с учётом стоимости вставки элемента не превышает: $ O(n_1\log n) $. Тогда число элементарных 
операций для $ n $ элементов будет составлять: $$ \log n\sum\limits_{i=1}^{n} n_i \leq n^2 \log n \implies 
T(\textit{symmetricClosure},\, n) = O(n^2\log n). $$

\newpage

\subsection{Алгоритм построения транзитивного замыкания бинарного отношения.}

\textbf{Описание алгоритма построения транзитивного замыкания бинарного отношения.} \\
\textbf{Вход:} список смежности бинарного отношения $ \rho $. \\
\textbf{Выход:} замкнутое относительно свойства транзитивности бинарное отношение $ \rho $. \\
\textbf{Метод:} для каждого элемента $ a $, находящегося в бинарном отношении $ \rho $ с некоторыми 
элементами $ b_i $, все элементы, находящиеся в списке смежности элемента $ b_i $, должны быть добавлены в 
список смежности элемента $ a $. Но поскольку после всего одного применения функции \textit{transitiveClosure} 
получившееся бинарное отношение может оказаться незамкнутым относительно свойства транзитивности, применение 
функции на $ \rho $ надо продолжать до тех пор, пока функция \textit{isTransitive} не вернёт \textbf{true}. \\

\par \textbf{Псевдокод алгоритма построения транзитивного замыкания бинарного отношения.}

\begin{lstlisting}[caption=Псевдокод алгоритма., mathescape]
transitiveClosureMachinery(binaryRelation)
{
	for element in binaryRelation:
		for subelement in element:
			for elt in binaryRelation[subelement]:
				binaryRelation[element].insert(elt);            
		
	return binaryRelation;
}

transitiveClosure(binaryRelation)
{
    while (!isTransitive(binaryRelation))
        binaryRelation = 
					transitiveClosureMachinery(binaryRelation);
    return binaryRelation;
}

\end{lstlisting}

\newpage

\par \textbf{Код программы, реализующей алгоритм построения транзитивного замыкания бинарного отношения.}

\begin{lstlisting}[caption=Код программы., mathescape]
map<int, set<int>> 
		transitiveClosure(map<int, set<int>> binaryRelation)
{
	set<int> ::iterator it, itHelper;

	for (auto element : binaryRelation)
	{
		it = element.second.begin();

		for (; it != element.second.end(); ++it)
		{
			itHelper = binaryRelation[*it].begin();

			for (; itHelper != binaryRelation[*it].end(); ++itHelper)            
				binaryRelation[element.first].insert(*itHelper);            
		}
	}

	return binaryRelation;
}

map<int, set<int>> 
		transitiveClosure(map<int, set<int>> binaryRelation)
{
    while (!isTransitive(binaryRelation))
        binaryRelation = 
					transitiveClosureMachinery(binaryRelation);

    return binaryRelation;
}

\end{lstlisting}

\newpage

\par \textbf{Результат тестирования программы транзитивного замыкания бинарного отношения.}

\par Для демонстрации работы программы рассмотрим произвольное отношение $ \delta $.
\par Перейдём на ручной ввод и сгенерируем 6 пар элементов, соответствующих бинарному отношению $ \delta $. 
Получаем следующие пары: 

\begin{figure}[h]
	\center{\includegraphics{/closures/transitiveClosure/binary_relation.png}}
	\caption{Бинарное отношение, не обладающее свойством транзитивности.}
\end{figure}

\par Как видно, данное отношение не является транзитивным. Построим транзитивное замыкание этого бинарного 
отношения:

\begin{figure}[h]
	\center{\includegraphics{/closures/transitiveClosure/closed_binary_relation.png}}
	\caption{Бинарное отношение после транзитивного замыкания.}
\end{figure}

\par Заметим, что $ (f \circ f)(\delta) $ (где $ f $ - функция \textit{transitiveClosureMachinery}) оказалось
недостаточно для замыкания исходного бинарного отношения.
\par Получившееся бинарное отношение является замкнутым относительно свойства транзитивности, что при третьем
применении функции \\ \textit{transitiveClosureMachinery} подтверждает выход программы \textit{isTransitive.}

\par \textbf{Оценка временной сложности алгоритма построения транзитивного замыкания.} 
\par Определим $ n $ как число уникальных элементов, встречающихся в бинарном отношении, $ n_i $ как число 
элементов в списке смежности $i$-го элемента, а $ n_{ij} $ как $j$-ый элемент в таком списке смежности.
Посчитаем число элементарных операций для того, чтобы свойство транзитивности было выполнено для одного 
элемента (например, первого): $$ n_{n_{11}} + n_{n_{12}} + \dots + n_{n_{1n}} = 
\sum\limits_{i=1}^{n} n_{n_{1i}} \leq n^2. $$
Тогда временная сложность выполнения операций для одного элемента с учётом сложности вставки элементов
не превышает $ O(n^2 \log n) $. Тогда временная сложность для $ n $ элементов будет равна $ O(n^3\log n) $. \\
Но также необходимо учесть, что построение транзитивного замыкания может не завершиться за один вызов 
функции, поэтому окончательная сложность алгоритма: $$ T(transitiveClosure,\,n) = O(Cn^3\log n), \; 1 
\leq C < \infty. $$

\newpage

\conclusion
\par В ходе лабораторной работы мною были изучены основные свойства бинарных отношений и операций их 
замыкания. В качестве практического задания мною были построены алгоритмы определения свойств рефлексивности,
симметричности и транзитивности, классификации бинарных отношений и построения основных замыканий бинарных 
отношений с использованием структуры set, были представлены псевдокоды написанных по построенным алгоритмам 
программ, а также проведена оценка временной сложности представленных алгоритмов.

\end{document}
