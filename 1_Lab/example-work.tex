\documentclass[bachelor, och, pract4, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа

				%    pract2      - отчет по практике,  2 курс
				%    pract3      - отчет по практике,  3 курс
				%    pract4      - отчет по практике,  4 курс
%    nir      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
%\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[english,russian]{babel}

% выделение ссылок цветом. чтобы включить- true
\usepackage[colorlinks=false]{hyperref}

\graphicspath{{figures/}}

\lstset{%
	language=C,
	backgroundcolor=\color{gray!12},
	basicstyle=\ttfamily\small,
	keywordstyle=\color{blue},
	stringstyle=\color{blue},
	showstringspaces=false,
	captionpos=b,
	numbers=left,
	numberstyle=\footnotesize\color{gray},
	frame=TB,
	tabsize=2,
	morekeywords={procedure, then, begin, end}
}

\renewcommand{\rmdefault}{cmr} % курсив и полужирный включаются здесь.
\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{теории функций и стохастического анализа} 
%\chairr{кафедра теории функций и стохастического анализа} % для практик!!!!
\chairr{завод "Тантал"}% для практик!!!!

% Тема работы

\title{Правила оформления курсовых и дипломных работ}

% Курс
\course{4}

% Группа
\group{451}

\department{механико-математического факультета}

% Специальность/направление код - наименование
%\napravlenie{01.03.02 "--- Прикладная математика и информатика}
\napravlenie{38.03.05 "--- Бизнес-информатика}
%\napravlenie{09.04.03 "--- Прикладная информатика}

% Для СТУДЕНТКИ!!!. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Чайковского Петра Ильича}

% Заведующий кафедрой
\chtitle{д.\,ф.-м.\,н., доцент} % степень, звание
\chname{С.\,П.\,Сидоров}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
\saname{Н.\,Ю.\,Агафонова} % для 451 гр
%\saname{А.\,К.\,Смирнов} % для 412 гр

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
\patitle{ведущий программист}
\paname{Д.\,Э.\,Кнутов}

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{5}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
%\practtype{производственная(базовая)}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
%\duration{4}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{29.06.2019}
\practFinish{26.07.2019}

% Год выполнения отчета
\date{2019}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering

\tableofcontents



\section{Постановка задачи}

\par \textbf{Цель работы} — изучение основных свойств бинарных отношений и операций 
замыкания бинарных отношений. \\

\par \textbf{Порядок выполнения работы:}

\par \textbf{1}. Разобрать основные определения видов бинарных отношений и 
разработать алгоритмы классификации бинарных отношений.

\par \textbf{2}. Изучить свойства бинарных отношений и рассмотреть основные системы 
замыкания на множестве бинарных отношений.

\par \textbf{3}. Разработать алгоритмы построения основных замыканий бинарных 
отношений.

\newpage

\section{Теоретические сведения по рассмотренным темам с их обоснованием}

\par \textbf{Определение.} Подмножества декартова произведения $ A \times B $ 
множеств $ A $ и $ B $ называется \textit{бинарными отношениями} между элементами
множеств $ A, B $ и обозначаются строчными греческими буквами: $ \rho, \sigma, 
\dots, \rho_1, \rho_2, \dots .$ \\

\par \textbf{Определение.} Бинарное отношение $ \rho \subset A \times A $ 
называется: \\
1. \textit{рефлексивным}, если $ (a,\,a) \in \rho $ для всякого $ a \in A $; \\
2. \textit{симметричным}, если $ (a,\,b) \in \rho \implies (b,\,a) \in \rho $; \\
3. \textit{антисимметричным}, если $ (a,\,b) \in \rho $ и $ (b,\,a) \in \rho 
\implies a = b $; \\
4. \textit{транзитивным}, если $ (a,\,b) \in \rho $ и $ (b,\,c) \in \rho \implies (a,\,c) \in \rho $. \\

Символом $ \Delta_A $ обозначается тождественное отношение на множестве $ A $, которое определяется по
формуле: $$ \Delta_A = \{\,(a,\,a)\,|\, a \in A\,\}. $$

Тогда бинарное отношение $ \rho \subset A \times A $ является: \\
1. \textit{рефлексивным}, если $ \Delta_A \subset \rho $; \\
2. \textit{симметричным}, если $ \rho^{-1} \subset \rho $; \\ 
3. \textit{антисимметричным}, если $ \rho \cap \rho^{-1} \subset \Delta_A $; \\
4. \textit{транзитивным}, если $ \rho\rho \subset \rho $. \\

\par \textbf{Определение.} Бинарное отношение $ \rho $ на множестве $ A $ называется: \\
1. \textit{отношением эквивалентности (эквивалентностью)}, если оно рефлексивно, симметрично и транзитивно. \\
2. \textit{отношением порядка (порядком)}, если оно рефлексивно, антисимметрично и транзитивно. \\
3. \textit{отношением квазипорядка (квазипорядком)}, если оно рефлексивно и транзитивно.

\newpage

\par \textbf{Определение.} Множество $ Z $ подмножеств множества $ A $ называется \textit{системой замыканий},
если оно замкнуто относительно пересечений, т.е. выполняется: $$ \bigcap B \in Z \quad \forall B \subset Z. $$
В частности, для $ \varnothing \subset Z $ выполняется $ \cap \varnothing = A \in Z $. \\

\par \textbf{Лемма 1. О системах замыканий бинарных отношений.} На множестве $ P(A^2) $ всех бинарных 
отношений между элементами множества $ A $ следующие множества являются системами замыканий: 
\par 1. $ Z_r $ - множество всех рефлексивных бинарных отношений между элементами множества $ A $. 
\par 2. $ Z_s $ - множество всех симметричных бинарных отношений между элементами множества $ A $.
\par 3. $ Z_t $ - множество всех транзитивных бинарных отношений между элементами множества $ A $.
\par 4. $ Z_{eq} = Eq(A) $ - множество всех отношений эквивалентности на множестве $ A $.
\par Множество $ Z_{as} $ всех антисимметричных бинарных отношений между элементами множества $ A $ не 
является системой замыканий. \\

\par \textbf{Определение.} \textit{Оператором замыкания} на множестве $ A $ называется отображение $ f $
множества всех подмножеств $ P(A) $ в себя, удовлетворяющее условиям: 
\par 1) $ X \subset Y \implies f(X) \subset f(Y) $;
\par 2) $ X \subset f(X) $;
\par 3) $ (f \circ f)(X) = f(X) $ \\
для всех $ X, Y \in P(A). $ Для подмножества $ X \subset A $ значение $ f(X) $ называется \textit{замыканием}
подмножества $ X $. \\

\newpage

\par \textbf{Лемма 2. О замыканиях бинарных отношений.} На множестве $ P(A^2) $ всех бинарных отношений 
между элементами множества $ A $ следующие отображения являются операторами замыканий:
\par 1) $ f_r(\rho) = \varrho \cup \Delta_A $ - наименьшее рефлексивное бинарное отношение, содержащее 
отношение $ \rho \subset A^2 $,

\par 2) $ f_s(\rho) = \varrho \cup \varrho^{-1} $ - наименьшее симметричное бинарное отношение, содержащее 
отношение $ \rho \subset A^2 $,

\par 3) $ f_t(\rho) = \bigcup\limits_{n=1}^{\infty}\rho^n $ - наименьшее транзитивное бинарное отношение, 
содержащее отношение $ \rho \subset A^2 $,

\par 4) $ f_{eq}(\rho) $ = $ (f_t \circ f_s \circ f_r)(\rho) $ - наименьшее отношение эквивалентности,
содержащее отношение $ \rho \subset A^2 $.

\section{Результаты работы}
\subsection{Алгоритм определения свойства рефлексивности.}

\textbf{Описание алгоритма определения свойства рефлексивности.} \\
\textbf{Вход:} список смежности бинарного отношения $ \rho $. \\
\textbf{Выход:} строка <<Бинарное отношение является/не является рефлексивным.>> и bool значение \textbf{true}
или \textbf{false}. \\
\textbf{Метод:} для каждого элемента $ a $, находящегося в бинарном отношении $ \rho $ (с некоторыми 
элементами $ b_i $), просматривается его список смежности. В этом списке смежности ищется сам элемент $ a $.
Алгоритм прекрщает свою работу, если был найден элемент $ a $, список смежности которого не содержит $ a $, 
или, если для всякого элемента $ a $ его список смежности содержит $ a $. \\

\par \textbf{Псевдокод алгоритма определения свойства рефлексивности.}

\begin{lstlisting}[caption=Псевдокод алгоритма., mathescape]
isReflexive(binaryRelation)
{
	for element in binaryRelation
	{
		flag = false;

		for subelement in element:
			if (subelement == element):			
				flag = true;
			
		if (!flag)
			return false;
	}

	return true;
}
\end{lstlisting}

\newpage

\par \textbf{Код программы, реализующей алгоритм определения свойства рефлексивности.}

\begin{lstlisting}[caption=Код программы., mathescape]
bool isReflexive(map<int, set<int>> binaryRelation)
{
	bool isReflexive = false;
	set<int> ::iterator it;
	int i;
	
	for (auto element : binaryRelation)
	{
		isReflexive = false;
		it = element.second.begin();

		for (; it != element.second.end(); ++it)
			if (element.first == *it)
			{
				isReflexive = !isReflexive;
				break;
			}
	
		if (!isReflexive)
			break;
	}
	
	cout << "\n" << 
		(isReflexive ? "\nBINARY RELATION IS REFLEXIVE.\n" : 
					   			 "\nBINARY RELATION IS NOT REFLEXIVE.\n");
	return isReflexive;
}
\end{lstlisting}

\newpage

\par \textbf{Результат тестирования программы определения свойства рефлексивности.}

\par Для демонстрации работы программы рассмотрим два произвольных бинарных отношения $ \rho $ и $ \delta $, 
для одного из которых свойство рефлексивности выполняется, а для другого нет.
\par Сгенерируем 8 пар элементов, соответствующих бинарному отношению $ \rho $. Получаем следующие пары: 

\begin{figure}[h]
	\center{\includegraphics{/reflexiveCheck/is_reflexive_check.png}}
	\caption{Пары элементов, находящихся в нерефлексивном бинарном отношении.}
\end{figure}

\par Как видно, данное отношение не является рефлексивным. Посмотрим на выход программы:

\begin{figure}[h]
	\center{\includegraphics{/reflexiveCheck/is_reflexive_check_failed.png}}
	\caption{Проверка на рефлексивность не пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение не является рефлексивным. Теперь рассмотрим 
бинарное отношение $ \delta $, на котором свойство рефлексивности выполняется. Рассмотрим 8 следующих пар: 

\begin{figure}[h]
	\center{\includegraphics{/reflexiveCheck/reflexive_binary_relation.png}}
	\caption{Пары элементов, находящихся в рефлексивном бинарном отношении.}
\end{figure}

\newpage

\par Как видно, отношение является рефлексивным. Посмотрим на выход программы: 

\begin{figure}[h]
	\center{\includegraphics{/reflexiveCheck/is_reflexive_check_success.png}}
	\caption{Проверка на рефлексивность пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение является рефлексивным.

\newpage

\subsection{Алгоритм определения свойства симметричности.}

\textbf{Описание алгоритма определения свойства симметричности.}
\textbf{Вход:} список смежности бинарного отношения $ \rho $. \\
\textbf{Выход:} строка <<Бинарное отношение является/не является симметричным.>> и bool значение \textbf{true}
или \textbf{false}. \\
\textbf{Метод:} для каждого элемента $ a $, находящегося в бинарном отношении $ \rho $ (с некоторыми 
элементами $ b_i $), просматривается его список смежности. Для каждого элемента $ b_i $ из списка смежности 
элемента $ a $ просматривается его список смежности, и в нём ищется элемент $ a $. Алгоритм прекращает свою 
работу, если был найден элемент $ b_i $ из списка смежности элемента $ a $, список смежности которого не 
содержит элемента $ a $, или, если для всякого элемента $ a $ списки смежностей элементов $ b_i $ 
содержат $ a $. \\

\par \textbf{Псевдокод алгоритма определения свойства симметричности.}

\begin{lstlisting}[caption=Псевдокод алгоритма., mathescape]
isSymmetric(binaryRelation)
{
	for element in binaryRelation			
		for subelement in element
		{
			flag = false

			if element in binaryRelation[subelement]
				flag = true

			if (!flag)
				return false;
		}

	return true;
}
\end{lstlisting}

\newpage

\par \textbf{Код программы, реализующей алгоритм определения свойства симметричности.}

\begin{lstlisting}[caption=Код программы., mathescape]
bool isSymmetric(map<int, set<int>> binaryRelation)
{
	bool isSymmetric = false;
	set<int> ::iterator it, itHelper;

	for (auto element : binaryRelation)
	{
		it = element.second.begin();

		for (; it != element.second.end(); ++it)
		{
			isSymmetric = false;

			if (!binaryRelation[*it].empty())
			{
				itHelper = binaryRelation[*it].begin();

				for (; itHelper != binaryRelation[*it].end(); ++itHelper)
					if (element.first == *itHelper)
					{
						isSymmetric = !isSymmetric;
						break;
					}
			}
            
			if (!isSymmetric)
			{
				cout << "\nBINARY RELATION IS NOT SYMMETRIC.\n";
				return false;
			}
		}
	}

	cout << "\nBINARY RELATION IS SYMMETRIC.\n";
	return true;
}
\end{lstlisting}

\newpage

\par \textbf{Результат тестирования программы определения свойства симметричности.}

\par Для демонстрации работы программы рассмотрим два произвольных бинарных отношения $ \rho $ и $ \delta $, 
для одгого из которых свойство симметричности выполняется, а для другого нет.
\par Сгенерируем 8 пар элементов, соответствующих бинарному отношению $ \rho $. Получаем следующие пары: 

\begin{figure}[h]
	\center{\includegraphics{/symmetricCheck/is_symmetric_check.png}}
	\caption{Пары элементов, находящихся в несимметричном бинарном отношении.}
\end{figure}

\par Как видно, данное отношение не является симметричным. Посмотрим на выход программы:

\begin{figure}[h]
	\center{\includegraphics{/symmetricCheck/is_symmetric_check_failed.png}}
	\caption{Проверка на симметричность не пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение не является симметричным. Теперь рассмотрим 
бинарное отношение $ \delta $, на котором свойство симметричности выполняется. Рассмотрим 8 следующих пар
(число сгенерированных пар элементов может быть меньше, поскольку некоторые пары при генерации могли совпасть): 

\begin{figure}[h]
	\center{\includegraphics{/symmetricCheck/symmetric_binary_relation.png}}
	\caption{Пары элементов, находящихся в симметричном бинарном отношении.}
\end{figure}

\newpage

\par Как видно, отношение является симметричным. Посмотрим на выход программы: 

\begin{figure}[h]
	\center{\includegraphics{/symmetricCheck/is_symmetric_check_success.png}}
	\caption{Проверка на симметричность пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение является симметричным.

\newpage

\subsection{Алгоритм определения свойства антисимметричности.}

\textbf{Описание алгоритма определения свойства антисимметричности.}
\textbf{Вход:} список смежности бинарного отношения $ \rho $. \\
\textbf{Выход:} строка <<Бинарное отношение является/не является антисимметричным.>> и bool значение 
\textbf{true} или \textbf{false}. \\
\textbf{Метод:} для каждого элемента $ a $, находящегося в бинарном отношении $ \rho $ (с некоторыми 
элементами $ b_i $), просматривается его список смежности. Для каждого элемента $ b_i $ из списка смежности 
элемента $ a $ просматривается его список смежности. В этом списке смежности не должно содержаться элемента 
$ a $, за исключением ситуации, когда $ a $ и $ b_i $ - один и тот же элемент, и переход из $ a $ в 
$ b_i $ - петля. \\

\par \textbf{Псевдокод алгоритма определения свойства антисимметричности.}

\begin{lstlisting}[caption=Псевдокод алгоритма., mathescape]
isAntisymmetric(binaryRelation)
{	
	for element in binaryRelation:	
		for subelement in element
		{
			isAntisymmetric = true;

			if subelement is not element
			{
				for elt in binaryRelation[subelement]
					if (elt == element)
						isAntisymmetric = false;
			}
	
			if (!isAntisymmetric)			
				return false;			
		}

	return true;
}
\end{lstlisting}

\newpage

\par \textbf{Код программы, реализующей алгоритм определения свойства антисимметричности.}

\begin{lstlisting}[caption=Код программы., mathescape]
bool isAntisymmetric(map<int, set<int>> binaryRelation)
{
	bool isAntisymmetric = false;
	set<int> ::iterator it, itHelper;

	for (auto element : binaryRelation)
	{
		it = element.second.begin();

		for (; it != element.second.end(); ++it)
		{
			isAntisymmetric = true;

			if (!binaryRelation[*it].empty() && *it != element.first)
			{
				itHelper = binaryRelation[*it].begin();

				for (; itHelper != binaryRelation[*it].end(); ++itHelper)
					if (*itHelper == element.first)
						isAntisymmetric = false;
			}

			if (!isAntisymmetric)
			{
				cout << "\nBINARY RELATION IS NOT ANTISYMMETRIC.\n";
				return false;
			}            
		}
	}

	cout << "\nBINARY RELATION IS ANTISYMMETRIC.\n";
	return true;
}
\end{lstlisting}

\newpage

\par \textbf{Результат тестирования программы определения свойства антисимметричности.}

\par Для демонстрации работы программы рассмотрим два произвольных бинарных отношения $ \rho $ и $ \delta $, 
для одгого из которых свойство антисимметричности выполняется, а для другого нет.
\par Сгенерируем 8 пар элементов (число сгенерированных пар элементов может быть меньше, поскольку некоторые
пары при генерации могли совпасть), соответствующих бинарному отношению $ \rho $. Получаем следующие пары: 

\begin{figure}[h]
	\center{\includegraphics{/antisymmetricCheck/is_antisymmetric_check.png}}
	\caption{Пары элементов, находящихся в неантисимметричном бинарном отношении.}
\end{figure}

\par Как видно, данное отношение не является антисимметричным. Посмотрим на выход программы:

\begin{figure}[h]
	\center{\includegraphics{/antisymmetricCheck/is_antisymmetric_check_failed.png}}
	\caption{Проверка на антисимметричность не пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение не является антисимметричным. Теперь рассмотрим 
бинарное отношение $ \delta $, на котором свойство антисимметричности выполняется. Рассмотрим 8 следующих пар: 

\begin{figure}[h]
	\center{\includegraphics{/antisymmetricCheck/antisymmetric_binary_relation.png}}
	\caption{Пары элементов, находящихся в симметричном бинарном отношении.}
\end{figure}

\newpage

\par Как видно, отношение является антисимметричным. Посмотрим на выход программы: 

\begin{figure}[h]
	\center{\includegraphics{/antisymmetricCheck/is_antisymmetric_check_success.png}}
	\caption{Проверка на симметричность пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение является антисимметричным.

\newpage

\subsection{Алгоритм определения свойства транзитивности.}

\textbf{Описание алгоритма определения свойства транзитивности.}
\textbf{Вход:} список смежности бинарного отношения $ \rho $. \\
\textbf{Выход:} строка <<Бинарное отношение является/не является транзитивным.>> и bool значение \textbf{true}
или \textbf{false}. \\
\textbf{Метод:} для каждого элемента $ a $, находящегося в бинарном отношении $ \rho $ (с некоторыми 
элементами $ b_i $), просматривается его список смежности. Для каждого элемента $ b_i $ из списка смежности 
элемента $ a $ просматривается его список смежности. Для удовлетворения условия транзитивности каждый элемент 
из списка смежности $ b_i $ должен содержаться в списке смежности элемента $ a $. Алгоритм завершает свою 
работу, если находится такой элемент, что это условие для него не выполняется, или после проверки и выполнения
этого условия для всякого элемента $ a $. \\

\par \textbf{Псевдокод алгоритма определения свойства транзитивности.}

\begin{lstlisting}[caption=Псевдокод алгоритма., mathescape]
isTransitive(binaryRelation)
{	
	for element in binaryRelation:	
		for subelement in element:		
			for elt in binaryRelation[subelement]
			{
				isTransitive = false;

				for eltSup in element:
					if (elt == eltSup)
						isTransitive = true

				if (!isTransitive)				
					return false;				
			}
		}
	}

	return true;
}
\end{lstlisting}

\newpage

\par \textbf{Код программы, реализующей алгоритм определения свойства транзитивности.}

\begin{lstlisting}[caption=Код программы., mathescape]
bool isTransitive(map<int, set<int>> binaryRelation)
{
	bool isTransitive = false;
	set<int> ::iterator it, itHelper, itSup;
	
	for (auto element : binaryRelation)
	{
		it = element.second.begin();
	
		for (; it != element.second.end(); ++it)
		{
			if (!binaryRelation[*it].empty())
			{
				itHelper = binaryRelation[*it].begin();
				
				for (; itHelper != binaryRelation[*it].end(); ++itHelper)
				{
					itSup = element.second.begin();
					isTransitive = false;

					for (; itSup != element.second.end(); ++itSup)
						if (*itHelper == *itSup)
							isTransitive = !isTransitive;

					if (!isTransitive)
					{
						cout << "\nBINARY RELATION IS NOT TRANSITIVE.\n";
						return false;
					}
				}
			}
		}
	}	
	cout << "\nBINARY RELATION IS TRANSITIVE.\n";
	return true;
}
\end{lstlisting}

\newpage

\par \textbf{Результат тестирования программы определения свойства транзитивности.}

\par Для демонстрации работы программы рассмотрим два произвольных бинарных отношения $ \rho $ и $ \delta $, 
для одгого из которых свойство транзитивности выполняется, а для другого нет.
\par Сгенерируем 8 пар элементов, соответствующих бинарному отношению $ \rho $. Получаем следующие пары: 

\begin{figure}[h]
	\center{\includegraphics{/transitiveCheck/is_transitive_check.png}}
	\caption{Пары элементов, находящихся в нетранзитивном бинарном отношении.}
\end{figure}

\par Как видно, данное отношение не является транзитивным. Посмотрим на выход программы:

\begin{figure}[h]
	\center{\includegraphics{/transitiveCheck/is_transitive_check_failed.png}}
	\caption{Проверка на транзитивность не пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение не является транзитивным. Теперь рассмотрим 
бинарное отношение $ \delta $, на котором свойство транзитивности выполняется. Перейдём на ручной ввод и 
введём 8 пар элементов: 

\begin{figure}[h]
	\center{\includegraphics{/transitiveCheck/transitive_binary_relation.png}}
	\caption{Пары элементов, находящихся в транзитивном бинарном отношении.}
\end{figure}

\newpage

\par Как видно, отношение является транзитивным. Посмотрим на выход программы: 

\begin{figure}[h]
	\center{\includegraphics{/transitiveCheck/is_transitive_check_success.png}}
	\caption{Проверка на транзитивность пройдена.}
\end{figure}

\par Выход программы совпадает с тем фактом, что отношение является транзитивным.

\newpage

\subsection{Алгоритм классификации бинарных отношений.}

Отдельно рассмотрим три функции, определяющих класс бинарного отношения, а именно: отношение эквивалентности,
отношение порядка или отношение квазипорядка. Тогда алгоритм, содержащий в себе эти три функции, может 
выглядеть следующим образом: \\
\textbf{Вход:} список смежности бинарного отношения $ \rho $. \\
\textbf{Выход:} строки <<Бинарное отношение является/не является отношением эквивалентности.>>, 
<<Бинарное отношение является/не является отношением порядка.>>, <<Бинарное отношение является/не 
является отношением квазипорядка.>> \\
\textbf{Метод:} последовательно запускаем функции проверки принадлежности бинарного отношение к соответствующему
классу. \\

\par \textbf{Код программы, реализующей алгоритм классификации бинарных отношений.}

\begin{lstlisting}[caption={Набор функций, осуществляющий классификацию бинарных отношений.}, mathescape]
void isEquivalence(map<int, set<int>> binaryRelation)
{
	if (isReflexive(binaryRelation) && 
			isSymmetric(binaryRelation) && 
			isTransitive(binaryRelation))
		cout << "\nBINARY RELATION IS AN EQUIVALENT RELATION.\n";
	else
		cout << "\nBINARY RELATION IS NOT AN EQUIVALENT RELATION.\n";
}
	
void isOrder(map<int, set<int>> binaryRelation)
{
	if (isReflexive(binaryRelation) && 
			isAntisymmetric(binaryRelation) && 
			isTransitive(binaryRelation))
		cout << "\BINARY RELATION IS AN ORDER RELATION.\n";
	else
		cout << "\BINARY RELATION IS NOT AN ORDER RELATION.\n";
}
	
void isQuasi(map<int, set<int>> binaryRelation)
{
	if (isReflexive(binaryRelation) && 
			isTransitive(binaryRelation))
		cout << "\nBINARY RELATION IS A QUASI-ORDER RELATION.\n";
	else
		cout << "\nBINARY RELATION IS NOT A QUASI-ORDER RELATION.\n";
}
\end{lstlisting}

\newpage

\subsection{Описание алгоритмов построения основных замыканий бинарных отношений}

\newpage

\subsection{Псевдокоды рассмотренных алгоритмов}

\newpage

\subsection{Коды программ, реализуюших рассмотренные алгоритмы}

\newpage

\subsection{Результаты тестирования программ}

\newpage

\subsection{Оценки сложности рассмотренных алгоритмов}

\newpage



\end{document}
